#
# Config
#

if command -v sudo > /dev/null && [[ $( id -u ) -ne 0 ]] ; then
    _sudo="sudo "
fi

#
# Aliases
#

# Core
alias -- -='cd -'
alias l='ls -lh'
alias sl='ls -lh'
alias lsl='ls -lh'
alias lsa='ls -lhA'
alias rm='rm -I'

# SSH
alias scpi='scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'
alias sshi='ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'

alias rsynci='rsync -e "ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"'

# Misc
alias tig='tig --all'
alias tree-no-git='tree -aI .git'
alias delpyc='find . -iname "*.pyc" -print -delete'
alias xc='xclip -sel clipboard'

command -v colordiff > /dev/null &&
    alias diff='colordiff'

command -v most > /dev/null &&
    alias man='man -P most'

# runas
if [[ -n "$_sudo" ]] ; then
    alias gitcmd='sudo -u git'
    alias wwwcmd='sudo -u www-data'
fi

# APT
alias update="${_sudo}apt update"
alias safeupgrade="${_sudo}apt upgrade"
alias clean="${_sudo}apt clean"
alias forget-new="${_sudo}aptitude forget-new"
alias keep-all="${_sudo}aptitude keep-all"
alias list-new="aptitude search ~N"

# VirtualBox
if command -v VBoxManage > /dev/null ; then
    alias vmlist='VBoxManage list vms'
    alias vmlistr='VBoxManage list runningvms'
fi

#
# Funções
#

vminit()
{
    [[ "$1" ]] || return 2
    vboxheadless --vrde off --startvm "$1" > /dev/null &
}

..()
{
    local hops="${1:-1}"
    local dest=""

    [[ $hops =~ ^[0-9]+$ ]] || {
        echo "uso: .. [N]" >&2
        return 2
    }

    while [[ $hops -gt 0 ]] ; do
        dest="${dest}../"
        let 'hops--'
    done

    cd "$dest"
}

mkcd()
{
    mkdir -pv "$@" || return
    cd "$*"
}

# Cria executável vazio
cx()
{
    local file="$1"

    if [[ -z "$file" ]] ; then
        echo "uso: cx /caminho/do/arquivo.sh" >&2
        return 2
    fi

    (
        set -ex
        mkdir -p "$( dirname "$file" )"
        touch "$file"
        chmod 755 "$file"
    )
}

# Corrige permissões: diretórios = 755, arquivos = 644
fixperms()
{
    local v

    [[ "$1" = "-v" ]] && { v="-v" ; shift ; }

    [[ -z "$1" ]] && {
        echo "$FUNCNAME: missing operand" >&2
        return 2
    }

    echo "Updating directory permissions of '${*}' to 755 (rwxr-xr-x) ..."
    find "${*}" -type d -exec chmod $v 755 {} \;

    [[ -n "$v" ]] && echo

    echo "Updating file permissions of '${*}' to 644 (rw-r--r--) ..."
    find "${*}" -type f -exec chmod $v 644 {} \;
}

# virtualenv / virtualenvwrapper
load_virtualenv()
{
    export WORKON_HOME=~/.virtualenvs
    source /usr/local/bin/virtualenvwrapper.sh || return

    if [[ -n "$1" ]] ; then
        echo "Carregando virtualenv: $1"
        workon "$1"
    fi
}

alias lovenv='load_virtualenv'

# nvm
load_nvm()
{
    export NVM_DIR="$HOME/.nvm"
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion
}

# rbenv
load_rbenv()
{
    if [[ -d "$HOME/.rbenv" ]] ; then
        export PATH="$HOME/.rbenv/bin:$PATH"
        eval "$(rbenv init -)"
    else
        echo "fatal: directory $HOME/.rbenv not found. Aborting." >&2
        return 1
    fi
}

# rvm
load_rvm()
{
    # Load RVM into a shell session *as a function*
    if [[ -s "$HOME/.rvm/scripts/rvm" ]] ; then
        source "$HOME/.rvm/scripts/rvm"
    else
        echo "fatal: RVM not found in $HOME/.rvm/scripts/rvm. Aborting." >&2
        return 1
    fi
}

# Docker
wipe_containers()
{
    local container
    local docker_opts

    [[ "$1" ]] || return 2

    [[ "$1" == "--rm" ]] && docker_opts="-a"

    for container in $( docker ps -q $docker_opts ) ; do
        docker "${@/--/}" "$container"
    done
}

kill_all_containers() { wipe_containers --kill  ; }
stop_all_containers() { wipe_containers --stop  ; }
rm_all_containers()   { wipe_containers --rm -v ; }

rm_dangling_images()
{
    local dangling_images="$( docker images -q --filter 'dangling=true' )"

    [[ -n "$dangling_images" ]] \
        && docker rmi $dangling_images \
        || echo "Nenhuma imagem órfã encontrada."
}

rm_dangling_volumes()
{
    local dangling_volumes="$( docker volume ls -q --filter 'dangling=true' )"

    [[ -n "$dangling_volumes" ]] \
        && docker volume rm $dangling_volumes \
        || echo "Nenhum volume órfão encontrado."
}

docker_cleanup()
{
    local cmd

    for cmd in \
        kill_all_containers \
        rm_all_containers \
        rm_dangling_images \
        rm_dangling_volumes
    do
        echo "-> $cmd"
        "$cmd" || return $?
    done
}

pgreps()
{
    [[ "$1" ]] || {
        echo "uso: $FUNCNAME <busca>" >&2
        return 2
    }

    ps aux | egrep "$1" | grep -v grep
}

debchangelog()
{
    [[ "$1" ]] || {
        echo "uso: $FUNCNAME <pacote>" >&2
        return 2
    }

    zless /usr/share/doc/$1/changelog*.gz
}

gci()
{
    local job_name="$1"
    local available_jobs

    if [[ ! -f .gitlab-ci.yml ]] ; then
        echo "fatal: arquivo .gitlab-ci.yml não encontrado no diretório atual."
        return 1
    fi

    if ! command -v gitlab-ci-multi-runner &> /dev/null ; then
        echo "fatal: comando 'gitlab-ci-multi-runner' não encontrado."
        return 1
    fi

    if [[ -z "$job_name" ]] ; then
        available_jobs="$(
            egrep -o '^[^[:blank:]].+:' .gitlab-ci.yml \
                | cut -d ':' -f 1 \
                | egrep -v '^\.|(image|services|stages|types|before_script|after_script|variables|cache)$' \
        )"

        if [[ "$( echo "$available_jobs" | wc -l )" == "1" ]] ; then
            job_name="$available_jobs"
        else
            echo "Jobs disponíveis:"
            echo
            echo "$available_jobs" | sed 's/^/  /'
            echo
            echo "Execute '$FUNCNAME <job>' para executar."

            return 0
        fi
    fi

    (
        set -x
        gitlab-ci-multi-runner exec docker "$job_name"
    )
}

#
# Limpeza
#

unset _sudo
